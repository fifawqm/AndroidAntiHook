//
// Created by luffyjet on 2018/5/15.
//

/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
#include <stdio.h>
#include <sys/ptrace.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>
#include <dlfcn.h>
#include <stdlib.h>
#include <android/log.h>

#ifndef _Included_com_wiseyq_safe_CCprotect
#define _Included_com_wiseyq_safe_CCprotect
#ifdef __cplusplus
extern "C" {
#endif

#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, "CCJNI", __VA_ARGS__)


pthread_t t_id;

//获取TracePid
int getnumberfor_str(char* str){
    if(str == NULL){
        return -1;
    }
    char result[20];
    int count = 0;
    while(*str != '\0'){
        if(*str >= 48 && *str <= 57){
            result[count] = *str;
            count++;
        }
        str++;
    }
    int val = atoi(result);
    return val;
}

//开启循环轮训检查TracePid字段
void thread_fuction() {
    int pid = getpid();
    int ppid = getppid();

    LOGD("pid:%d", pid);
    LOGD("ppid:%d", ppid);


    char file_name[20] = {'\0'};
    sprintf(file_name, "/proc/%d/status",pid);
    char linestr[256];
    int i=0, traceid;
    FILE *fp;
    while(1){
        i = 0;
        fp = fopen(file_name,"r");
        if(fp == NULL){
            break;
        }
        while(!feof(fp)){
            fgets(linestr, 256, fp);
            if(i == 5){
                LOGD("trace:%s", linestr);
                traceid = getnumberfor_str(linestr);
                LOGD("traceId:%d", traceid);
                if(traceid > 0 && ppid!=traceid){
                    LOGD("I was be traced...trace pid:%d",traceid);
                    kill(pid, SIGKILL);
                    exit(0);
                }
                break;
            }
            i++;
        }
        fclose(fp);
        sleep(5);
    }
}

//检查 IDA 工具默认监听端口
int find_debug_port(){
    char szLines[1024] = {0};
    int nFind = 0;

    FILE *fp = fopen("/proc/net/tcp", "r");
    if (fp != NULL)
    {
        while (fgets(szLines, sizeof(szLines), fp))
        {
            //23946端口
            if (strstr(szLines, "00000000:5D8A"))
            {
                nFind = 1;
                printf("find\r\n");
                break;
            }
        }

        fclose(fp);
    }
    else
    {
        printf("fopen error\r\n");
    }

    if (nFind == 0)
    {
        printf("no find\r\n");
    }

    return nFind;
}


void create_thread_check_traceid(){
    int err = pthread_create(&t_id,NULL, thread_fuction, NULL);
    if(err != 0 ) {
        LOGD("create thread fail: %s\n",strerror(err));
    }
}

jint JNI_OnLoad(JavaVM* vm, void* reserved){
    LOGD("JNI on load...");

    //自己附加
    LOGD("ptrace myself...");
    ptrace(PTRACE_TRACEME, 0, 0, 0);

    //声明变量
    JNIEnv* env = NULL;

    //检测自己有没有被trace
    create_thread_check_traceid();

    //获取JNI环境对象
    if ((*vm)->GetEnv(vm, (void**) &env, JNI_VERSION_1_4) != JNI_OK) {
        LOGD("ERROR: GetEnv failed\n");
        return JNI_ERR;
    }

    return JNI_VERSION_1_4;
}

//onUnLoad方法，在JNI组件被释放时调用
void JNI_OnUnload(JavaVM* vm, void* reserved){
    LOGD("JNI unload...");
}

JNIEXPORT void JNICALL
Java_com_wiseyq_safe_CCProctect_uninstall(JNIEnv *env, jclass type, jstring soPath_) {
    const char *soPath = (*env)->GetStringUTFChars(env, soPath_, 0);
    void*handle=dlopen(soPath,RTLD_NOW);
    int count=4;
    int i=0;
    for(i=0;i<count;i++){
        if(NULL!=handle)
        {
            dlclose(handle);
        }
    }
    (*env)->ReleaseStringUTFChars(env, soPath_, soPath);
}

#ifdef __cplusplus
}
#endif
#endif
